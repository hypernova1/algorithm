# 배열
배열은 연속된 메모리 영역에 저장된 데이터 메모리로, 조회가 O(1), 추가 및 삭제는 O(n)의 복잡도를 가지고 있다.

배열 문제가 나왔을 땐 배열이 정렬되었는지 아닌지 확인한다.

## 퀴즈 1
숫자로 구성된 배열이 주어졌을 경우 중복된 숫자가 있는지 확인하는 함수 구현

### 해결 1. for 루프를 두 번 써서 순차적으로 하나씩 살펴본다.

~~~java
int solution(int[] numbers) {
  for (int i = 0; i < numbers.length; i++) {
    for (int j = i + 1; j < numbers.length; j++) {
      if (numbers[i] == numbers[j]) {
        return true;
      }
    }
  }
  return false;
}  
~~~
시간 복잡도: O(n) * (On) = **O(n^2)**

공간 복잡도: 추가적으로 사용하는 변수가 없기 때문에 **O(1)**

공간 복잡도 효율이 좋지만 속도가 너무 느리다.


### 해결 2. 배열을 정렬한 후 확인한다.

~~~java
int solution(int[] numbers) {
  Arrays.sort(numbers); //시간 복잡도 O(NlogN), 공간 복잡도: O(logN)
  for (int i = 0; i < numbers.length - 1; i++) {
    if (numbers[i] == numbers[i + 1]) {
      return true
    }
  }
  return false;
}  
~~~

시간 복잡도: **O(NlogN)**

공간 복잡도: **O(logN)**

첫 번째 해결 방법보다 공간 복잡도는 늘었지만 속도가 많이 줄었다.

### 해결 3. Set을 사용한다.

~~~java
int solution(int[] numbers) {
  Set<Integer> numberSet = new HashSet<>();
  for (int num : numbers) {
    if (numberSet.contains(num)) {
      return true;
    } else {
      numberSet.add(num);
    }
  }
  return false;
}
~~~

시간 복잡도: 배열을 n만큼 한 번만 순회한다. **O(n)**

공간 복잡도: 배열의 길이만큼 Set의 길이도 정해진다. **O(n)**
